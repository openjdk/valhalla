#
# Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# Translators please note do not translate the options themselves
java.launcher.opt.header  =   Syntaxe : {0} [options] <mainclass> [args...]\n           (pour exécuter une classe)\n   ou  {0} [options] -jar <jarfile> [args...]\n           (pour exécuter un fichier JAR)\n   ou  {0} [options] -m <module>[/<mainclass>] [args...]\n       {0} [options] --module <module>[/<mainclass>] [args...]\n           (pour exécuter la classe principale dans un module)\n\n Les arguments suivant la classe principale -jar <jarfile>, -m ou --module\n <module>/<mainclass> sont transmis en tant qu''arguments à la classe principale.\n\n où options comprend les éléments suivants :\n\n

java.launcher.opt.vmselect   =\    {0}\t  pour sélectionner la machine virtuelle "{1}"\n
java.launcher.opt.hotspot    =\    {0}\t  est un synonyme pour la machine virtuelle "{1}"  [en phase d''abandon]\n

# Translators please note do not translate the options themselves
java.launcher.opt.footer = \    -cp <chemin de recherche de classe de répertoires et de fichiers ZIP/JAR>\n    -classpath <chemin de recherche de classe de répertoires et de fichiers ZIP/JAR>\n    --class-path <chemin de recherche de classe de répertoires et de fichiers ZIP/JAR>\n                  Liste, avec séparateur {0}, de répertoires, d''archives JAR\n                  et d'archives ZIP pour rechercher des fichiers de classe.\n    -p <chemin de modules>\n    --module-path <chemin de modules>...\n                  Liste, avec séparateur {0}, de répertoires, chaque répertoire\n                  est un répertoire de modules.\n    --upgrade-module-path <chemin de modules>...\n                  Liste, avec séparateur {0}, de répertoires, chaque répertoire\n                  est un répertoire de module qui remplace les modules\n                  pouvant être mis à niveau dans l'image d'exécution\n    --add-modules <nom de module>[,<nom de module>...]\n                  modules racine à résoudre en plus du module initial.\n                  <nom de module> peut également être ALL-DEFAULT, ALL-SYSTEM,\n                  ALL-MODULE-PATH.\n    --list-modules\n                  répertorier les modules observables et quitter\n    -d <nom de module>\n    --describe-module <nom de module>\n                  décrire un module et quitter\n    --dry-run     créer une machine virtuelle et charger la classe principale mais ne pas exécuter la méthode principale.\n                  L'option--dry-run peut être utile pour la validation des\n                  options de ligne de commande telles que la configuration du système de modules.\n    --validate-modules\n                  valider tous les modules et quitter\n                  L'option --validate-modules peut être utile pour la recherche de\n                  conflits et d'autres erreurs avec des modules dans le chemin de modules.\n    -D<name>=<value>\n                  définir une propriété système\n    -verbose:[class|module|gc|jni]\n                  activer la sortie en mode verbose\n    -version      afficher la version de produit dans le flux d'erreur et quitter\n    --version     afficher la version de produit dans le flux de sortie et quitter\n    -showversion  afficher la version de produit dans le flux d'erreur et continuer\n    --show-version\n                  afficher la version de produit dans le flux de sortie et continuer\n    --show-module-resolution\n                  afficher la sortie de résolution de module lors du démarrage\n    -? -h -help\n                  afficher ce message d'aide dans le flux d'erreur\n    --help        afficher ce message d'erreur dans le flux de sortie\n    -X            afficher l'aide sur des options supplémentaires dans le flux d'erreur\n    --help-extra  afficher l'aide sur des options supplémentaires dans le flux de sortie\n    -ea[:<packagename>...|:<classname>]\n    -enableassertions[:<packagename>...|:<classname>]\n                  activer des assertions avec la granularité spécifiée\n    -da[:<packagename>...|:<classname>]\n    -disableassertions[:<packagename>...|:<classname>]\n                  désactiver des assertions avec la granularité spécifiée\n    -esa | -enablesystemassertions\n                  activer des assertions système\n    -dsa | -disablesystemassertions\n                  désactiver des assertions système\n    -agentlib:<libname>[=<options>]\n                  charger la bibliothèque d'agent natif <libname>, par ex. -agentlib:jdwp\n                  voir également -agentlib:jdwp=help\n    -agentpath:<pathname>[=<options>]\n                  charger la bibliothèque d'agent natif par nom de chemin complet\n    -javaagent:<jarpath>[=<options>]\n                  charger \
l'agent de langage de programmation, voir java.lang.instrument\n    -splash:<imagepath>\n                  afficher l'écran d'accueil avec l'image indiquée\n                  Les images redimensionnées HiDPI sont automatiquement prises en charge et utilisées\n                  si elles sont disponibles. Le nom de fichier d'une image non redimensionnée, par ex. image.ext,\n                  doit toujours être transmis comme argument à l'option -splash.\n                  L'image redimensionnée fournie la plus appropriée sera automatiquement\n                  sélectionnée.\n                  Pour plus d'informations, reportez-vous à la documentation relative à l'API SplashScreen\n    fichiers @argument\n                  fichiers d'arguments contenant des options\n    --disable-@files\n                  empêcher le développement supplémentaire de fichiers d'arguments\nAfin d'indiquer un argument pour une option longue, vous pouvez utiliser --<name>=<value> ou\n--<name> <value>.\n

# Translators please note do not translate the options themselves
java.launcher.X.usage=\n    -Xbatch           désactivation de la compilation en arrière-plan\n    -Xbootclasspath/a:<répertoires et fichiers ZIP/JAR séparés par des {0}>\n                      ajout à la fin du chemin de classe bootstrap\n    -Xcheck:jni       exécution de contrôles supplémentaires pour les fonctions JNI\n    -Xcomp            force la compilation de méthodes au premier appel\n    -Xdebug           fourni pour la compatibilité amont\n    -Xdiag            affichage de messages de diagnostic supplémentaires\n    -Xfuture          activation des contrôles les plus stricts en vue d''anticiper la future valeur par défaut\n    -Xint             exécution en mode interprété uniquement\n    -Xinternalversion\n                      affiche des informations de version JVM plus détaillées que\n                      l''option -version\n    -Xloggc:<file>    journalisation du statut de l''opération de ramasse-miette dans un fichier avec horodatages\n    -Xmixed           exécution en mode mixte (valeur par défaut)\n    -Xmn<size>        définit les tailles initiale et maximale (en octets) de la portion de mémoire\n                      pour la jeune génération (nursery)\n    -Xms<size>        définition de la taille initiale des portions de mémoire Java\n    -Xmx<size>        définition de la taille maximale des portions de mémoire Java\n    -Xnoclassgc       désactivation de l''opération de ramasse-miette de la classe\n    -Xrs               réduction de l''utilisation des signaux OS par Java/la machine virtuelle (voir documentation)\n    -Xshare:auto      utilisation des données de classe partagées si possible (valeur par défaut)\n    -Xshare:off       aucune tentative d''utilisation des données de classe partagées\n    -Xshare:on        utilisation des données de classe partagées obligatoire ou échec de l''opération.\n    -XshowSettings    affichage de tous les paramètres et poursuite de l''opération\n    -XshowSettings:all\n                      affichage de tous les paramètres et poursuite de l''opération\n    -XshowSettings:locale\n                       affichage de tous les paramètres d''environnement local et poursuite de l''opération\n    -XshowSettings:properties\n                       affichage de tous les paramètres de propriété et poursuite de l''opération\n    -XshowSettings:vm affichage de tous les paramètres de machine virtuelle et poursuite de l''opération\n    -Xss<size>        définition de la taille de pile de thread Java\n    -Xverify          définit le mode du vérificateur de code exécutable\n    --add-reads <module>=<target-module>(,<target-module>)*\n                      met à jour <module> pour lire <target-module>, sans tenir compte\n                      de la déclaration de module. \n                      <target-module> peut être ALL-UNNAMED pour lire tous les\n                      modules sans nom.\n    --add-exports <module>/<package>=<target-module>(,<target-module>)*\n                      met à jour <module> pour exporter <package> vers <target-module>,\n                      sans tenir compte de la déclaration de module.\n                      <target-module> peut être ALL-UNNAMED pour effectuer un export vers tous\n                      les modules sans nom.\n    --add-opens <module>/<package>=<target-module>(,<target-module>)*\n                      met à jour <module> pour ouvrir <package> vers\n                      <target-module>, sans tenir compte de la déclaration de module.\n    --illegal-access=<value>\n                      autorise ou refuse l''accès à des membres de types dans des modules nommés\n                      par code \
dans des modules sans nom.\n                      <value> est l''une des valeurs suivantes : "deny", "permit", "warn" ou "debug"\n                      Cette option sera enlevée dans une version ultérieure.\n    --limit-modules <module name>[,<module name>...]\n                      limite l''univers des modules observables\n    --patch-module <module>=<file>({0}<file>)*\n                      remplace ou augmente un module avec des classes et des ressources\n                      dans des fichiers JAR ou des répertoires.\n    --disable-@files  désactive d''autres développements de fichier d''argument\n\nCes options supplémentaires peuvent être modifiées sans préavis.\n

# Translators please note do not translate the options themselves
java.launcher.X.macosx.usage=\nLes options suivantes sont propres à Mac OS X :\n    -XstartOnFirstThread\n                      exécute la méthode main() sur le premier thread (AppKit)\n    -Xdock:name=<nom d'application>\n                      remplace le nom d'application par défaut affiché dans l'ancrage\n    -Xdock:icon=<chemin vers le fichier d'icône>\n                      remplace l'icône par défaut affichée dans l'ancrage\n\n

java.launcher.cls.error1=Erreur : impossible de trouver ou de charger la classe principale {0}\nCausé par : {1}: {2}
java.launcher.cls.error2=Erreur : la méthode principale n''est pas {0} dans la classe {1}, définissez la méthode principale comme suit :\n   public static void main(String[] args)
java.launcher.cls.error3=Erreur : la méthode principale doit renvoyer une valeur de type void dans la classe {0}, \ndéfinissez la méthode principale comme suit :\n   public static void main(String[] args)
java.launcher.cls.error4=Erreur : la méthode principale est introuvable dans la classe {0}, définissez la méthode principale comme suit :\n   public static void main(String[] args)\nou une classe d''applications JavaFX doit étendre {1}
java.launcher.cls.error5=Erreur : des composants d'exécution JavaFX obligatoires pour exécuter cette application sont manquants.
java.launcher.cls.error6=Erreur : LinkageError lors du chargement de la classe principale {0}\n\t{1}
java.launcher.cls.error7=Erreur : impossible d''initialiser la classe principale {0}\nCausé par : {1}: {2}
java.launcher.jar.error1=Erreur : une erreur inattendue est survenue lors de la tentative d''ouverture du fichier {0}
java.launcher.jar.error2=fichier manifeste introuvable dans {0}
java.launcher.jar.error3=aucun attribut manifest principal dans {0}
java.launcher.jar.error4=erreur lors du chargement de l''agent Java dans {0}
java.launcher.init.error=erreur d'initialisation
java.launcher.javafx.error1=Erreur : la signature de la méthode launchApplication JavaFX est incorrecte, la\nméthode doit être déclarée statique et renvoyer une valeur de type void
java.launcher.module.error1=le module {0} n''a pas d''attribut MainClass, utilisez -m <module>/<main-class>
java.launcher.module.error2=Erreur : impossible de trouver ou charger la classe principale {0} dans le module {1}
java.launcher.module.error3=Erreur : impossible de charger la classe principale {0} dans le module {1}\n\t{2}
java.launcher.module.error4={0} introuvable
java.launcher.module.error5=Erreur : impossible d''initialiser la classe principale {0} dans le module {1}\nCausé par : {1}: {2}
